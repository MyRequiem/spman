#! /usr/bin/env python3
# -*- coding: utf-8 -*-

# update.py file is part of spman

# Copyright 2016 MyRequiem <mrvladislavovich@gmail.com>
# All rights reserved

# spman - Slackware package manager
# Home page: https://github.com/MyRequiem/spman

# Spman is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

"""
Update PACKAGES.TXT, SLACKBUILDS.TXT and
ChangeLog.txt for each repository
"""

from os import (
    path,
    remove
)
from subprocess import call
from ssl import _create_unverified_context
from urllib.request import urlopen

from spman.maindata import MainData


class Update(object):
    """
    Update PACKAGES.TXT, SLACKBUILDS.TXT and
    ChangeLog.txt for each repository
    """
    def __init__(self):
        self.maindata = MainData()
        self.spman_conf = self.maindata.get_spman_conf()

    def start(self):
        """
        start update all local repository
        """
        # dict {'repo_name': 'url', ...}
        repos = self.maindata.get_repo_dict()
        # slackware version
        os_version = self.maindata.get_os_version()
        # machine architecture
        arch = 'x86_64' if self.maindata.arch == 'x86_64' else 'x86'

        for repo in sorted(repos):
            print(('\n{0}Update repository:{1} '
                   '{2}{3}').format(self.maindata.clrs['yellow'],
                                    self.maindata.clrs['cyan'],
                                    repo,
                                    self.maindata.clrs['reset']))
            # repo file name
            repo_txt = 'SLACKBUILDS.TXT' if repo == 'sbo' else 'PACKAGES.TXT'
            # full path to local repo file
            repo_file = '{0}{1}/{2}'.format(self.spman_conf['REPOS_PATH'],
                                            repo,
                                            repo_txt)
            # log file name
            log_txt = 'ChangeLog.txt'
            # full path to local log file
            log_file = '{0}{1}/{2}'.format(self.spman_conf['LOGS_PATH'],
                                           repo,
                                           log_txt)

            # URL's for remote logs and repo files
            if repo == 'alienbob':
                log_url = '{0}{1}'.format(repos[repo], log_txt)
                repo_url = '{0}{1}/{2}/{3}'.format(repos[repo],
                                                   os_version,
                                                   arch,
                                                   repo_txt)
            elif repo == 'multilib':
                log_url = '{0}{1}'.format(repos[repo], log_txt)
                repo_url = '{0}{1}/{2}'.format(repos[repo],
                                               os_version,
                                               repo_txt)
            elif repo == 'sbo':
                log_url = '{0}{1}/{2}'.format(repos[repo],
                                              os_version,
                                              log_txt)
                repo_url = '{0}{1}/{2}'.format(repos[repo],
                                               os_version,
                                               repo_txt)
            else:
                arch_sl = '64' if self.maindata.arch == 'x86_64' else ''
                rep = '{0}slackware{1}-{2}'.format(repos[repo],
                                                   arch_sl,
                                                   os_version)
                log_url = '{0}/{1}'.format(rep, log_txt)
                repo_url = '{0}/patches/{1}'.format(rep, repo_txt)

            # check exist local log and repo file
            repo_file_exist = path.isfile(repo_file)
            log_file_exist = path.isfile(log_file)
            if not repo_file_exist and not log_file_exist:
                self.download(repo_file, repo_url)
                self.download(log_file, log_url)
                continue
            elif not log_file_exist:
                self.download(log_file, log_url)
                continue
            elif not repo_file_exist:
                self.download(repo_file, repo_url)

            # check size local and remote ChangeLog.txt
            print('{0}Wait...{1}'.format(self.maindata.clrs['grey'],
                                         self.maindata.clrs['reset']))

            if not self.check_file_size(log_file, log_url):
                # rename ChangeLog.txt --> ChangeLog.txt_old
                call('mv {0} {0}_old'.format(log_file), shell=True)
                # delete local PACKAGES.TXT (SLACKBUILDS.TXT)
                remove(repo_file)
                # download new PACKAGES.TXT (SLACKBUILDS.TXT) and ChangeLog.txt
                self.download(repo_file, repo_url)
                self.download(log_file, log_url)
                # show diff
                print()
                call(('diff -U 0 {0}_old {0} | grep -v @@ | '
                      'grep -vE "\\-\\-\\-" | '
                      'grep -vE "\\+\\+\\+"').format(log_file), shell=True)
                # delete ChangeLog.txt_old
                remove('{0}_old'.format(log_file))

            print('{0}Done{1}'.format(self.maindata.clrs['grey'],
                                      self.maindata.clrs['reset']))
        print()

    def download(self, dfile, url):
        """
        download file
        """
        print('Downloading: {0}'.format(url))
        call('wget {0} --directory-prefix='
             '{1}/ {2}'.format(self.spman_conf['WGET_OPT'],
                               '/'.join(dfile.split('/')[:-1]),
                               url),
             shell=True)

        if not path.isfile(dfile):
            print(('{0}Can\'t download file:{1} '
                   '{2}').format(self.maindata.clrs['red'],
                                 self.maindata.clrs['reset'],
                                 url))
            raise SystemExit

    def check_file_size(self, local, remote):
        """
        check size local and remote ChangeLog.txt
        """
        if self.get_remote_file_size(remote) == path.getsize(local):
            return True

        return False

    @staticmethod
    def get_remote_file_size(remote):
        """
        get remote file size
        """
        filelen = 0
        _context = _create_unverified_context()
        headers = urlopen(remote, context=_context).getheaders()
        # >>> headers
        # [
        #   ...
        #   ('Accept-Ranges', 'bytes'),
        #   ('Content-Length', '391488'),
        #   ('Connection', 'close'),
        #   ('Content-Type', 'text/plain')
        # ]
        for header in headers:
            if header[0] == 'Content-Length':
                filelen = int(header[1])
                break

        return filelen
